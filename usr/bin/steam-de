#!/bin/bash

config_dir=${XDG_CONFIG_HOME:-$HOME/.config}

# even though gamescope itself runs on wayland,
# apps under gamescope should use XWayland
export XDG_SESSION_TYPE=x11

# don't create a desktop portal to avoid issues with some apps
export XDG_DESKTOP_PORTAL_DIR=''

# steam deck does this, I don't know why but let's keep it for now.
unset DISPLAY XAUTHORITY

# Fix intel color corruption
# might come with some performance degradation but is better than a corrupted
# color image
export INTEL_DEBUG=norbc
export mesa_glthread=true

# Show VRR controls in Steam
export STEAM_GAMESCOPE_VRR_SUPPORTED=1

# Some environment variables by default (taken from Deck session)
export SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS=0

# Enable Mangoapp
export STEAM_MANGOAPP_PRESETS_SUPPORTED=1
export STEAM_USE_MANGOAPP=0
export MANGOHUD_CONFIGFILE=$(mktemp /tmp/mangohud.XXXXXXXX)

export STEAM_USE_DYNAMIC_VRS=1
export RADV_FORCE_VRS_CONFIG_FILE=$(mktemp /tmp/radv_vrs.XXXXXXXX)

# Plop GAMESCOPE_MODE_SAVE_FILE into $config_dir
export GAMESCOPE_MODE_SAVE_FILE="${config_dir}/gamescope/modes.cfg"
export GAMESCOPE_PATCHED_EDID_FILE="${config_dir}/gamescope/edid.bin"

# Set up first time bootstrap status
export STEAM_BOOTSTRAP_CONFIG="${config_dir}/gamescope/bootstrap.cfg"

# Make path to gamescope mode save file.
mkdir -p "$(dirname "$GAMESCOPE_MODE_SAVE_FILE")"
touch "$GAMESCOPE_MODE_SAVE_FILE"
#echo "Making Gamescope Mode Save file at \"$GAMESCOPE_MODE_SAVE_FILE\""

# Make path to Gamescope edid patched file.
mkdir -p "$(dirname "$GAMESCOPE_PATCHED_EDID_FILE")"
touch "$GAMESCOPE_PATCHED_EDID_FILE"
#echo "Making Gamescope patched edid at \"$GAMESCOPE_PATCHED_EDID_FILE\""

# Make path to Steam bootstrap config file.
mkdir -p "$(dirname "$STEAM_BOOTSTRAP_CONFIG")"
touch "$STEAM_BOOTSTRAP_CONFIG"

# Support for gamescope tearing with GAMESCOPE_ALLOW_TEARING atom
export STEAM_GAMESCOPE_HAS_TEARING_SUPPORT=1

# Enable tearing controls in steam
export STEAM_GAMESCOPE_TEARING_SUPPORTED=1

# There is no way to set a color space for an NV12
# buffer in Wayland. And the color management protocol that is
# meant to let this happen is missing the color range...
# So just workaround this with an ENV var that Remote Play Together
# and Gamescope will use for now.
export GAMESCOPE_NV12_COLORSPACE=k_EStreamColorspace_BT601

export STEAM_GAMESCOPE_HDR_SUPPORTED=1

# Initially write no_display to our config file
# so we don't get mangoapp showing up before Steam initializes
# on OOBE and stuff.
mkdir -p "$(dirname "$MANGOHUD_CONFIGFILE")"
echo "no_display" > "$MANGOHUD_CONFIGFILE"

# Prepare our initial VRS config file
# for dynamic VRS in Mesa.
mkdir -p "$(dirname "$RADV_FORCE_VRS_CONFIG_FILE")"
echo "1x1" > "$RADV_FORCE_VRS_CONFIG_FILE"

# To expose vram info from radv
export WINEDLLOVERRIDES=dxgi=n

# Workaround for steam getting killed immediatly during reboot
export STEAMOS_STEAM_REBOOT_SENTINEL="/tmp/steamos-reboot-sentinel"

# Workaround for steam getting killed immediatly during shutdown
# Same idea as reboot sentinel above
export STEAMOS_STEAM_SHUTDOWN_SENTINEL="/tmp/steamos-shutdown-sentinel"

# Enable volume key management via steam for this session
export STEAM_ENABLE_VOLUME_HANDLER=1

# Have SteamRT's xdg-open send http:// and https:// URLs to Steam
export SRT_URLOPEN_PREFER_STEAM=1

# Disable automatic audio device switching in steam, now handled by wireplumber
export STEAM_DISABLE_AUDIO_DEVICE_SWITCHING=1

# Enable support for xwayland isolation per-game in Steam
export STEAM_MULTIPLE_XWAYLANDS=1

# We have the Mesa integration for the fifo-based dynamic fps-limiter
export STEAM_GAMESCOPE_DYNAMIC_FPSLIMITER=1

# We have NIS support
export STEAM_GAMESCOPE_NIS_SUPPORTED=1

# Don't wait for buffers to idle on the client side before sending them to gamescope
export vk_xwayland_wait_ready=false

# Let steam know it cannot unmount drives without superuser privileges
export STEAM_ALLOW_DRIVE_UNMOUNT=0

# We no longer need to set GAMESCOPE_EXTERNAL_OVERLAY from steam, mangoapp now does it itself
export STEAM_DISABLE_MANGOAPP_ATOM_WORKAROUND=1

# Enable horizontal mangoapp bar
export STEAM_MANGOAPP_HORIZONTAL_SUPPORTED=1

# Scaling support
export STEAM_GAMESCOPE_FANCY_SCALING_SUPPORT=1

# Color management support
# export STEAM_GAMESCOPE_COLOR_MANAGED=1
export STEAM_GAMESCOPE_VIRTUAL_WHITE=1

# Set input method modules for Qt/GTK that will show the Steam keyboard
export QT_IM_MODULE=steam
export GTK_IM_MODULE=Steam

# To play nice with the short term callback-based limiter for now
export GAMESCOPE_LIMITER_FILE=$(mktemp /tmp/gamescope-limiter.XXXXXXXX)

ulimit -n 524288

# Source user environment
if [ -f "${HOME}/.profile" ]; then
    source "${HOME}/.profile"
fi

# Source user configurations
if [ -f "${config_dir}/gamescope/settings.cfg" ]; then
    source "${config_dir}/gamescope/settings.cfg"
fi

log_fatal() {
	echo "$@" >> "$HOME/fatal.log"
}

# Fail early if we don't have a proper runtime directory setup
if [ -z "$XDG_RUNTIME_DIR" ]; then
	log_fatal "XDG_RUNTIME_DIR not set"
	exit 1
fi

# Create run directory file for startup and stats sockets
tmpdir=$(mktemp -d "$XDG_RUNTIME_DIR/gamescope.XXXXXXX")
if [ -z "$tmpdir" ]; then
	log_fatal "Failed to create temporary directory in which to create stats session sockets"
	exit 1
fi

# Setup socket for gamescope
socket="$tmpdir/startup.socket"
stats="$tmpdir/stats.pipe"

export GAMESCOPE_STATS="$stats"
mkfifo -- "$stats"
mkfifo -- "$socket"

# Define session if not overriden
STEAMCMD="steam -gamepadui -steamos3 -steampal -steamdeck"

GAMESCOPECMD="/usr/bin/gamescope \
--cursor '${HOME}/.local/share/Steam/tenfoot/resource/images/cursors/arrow.png' \
--cursor-scale-height $(expr 2160 / ${GAMESCOPE_CURSOR_SCALE:-2})
--adaptive-sync \
--fade-out-duration 200 \
--hide-cursor-delay 3000 \
--ready-fd $socket \
--stats-path $stats \
--steam \
--xwayland-count 2 \
"

# FIXME move logs to proper log location
# Log rotate the last session
if [ -f "${HOME}"/.steam-stdout.log ]; then
    cp "${HOME}"/.steam-stdout.log "${HOME}"/.steam-stdout.log.old
fi
if [ -f "${HOME}"/.gamescope-stdout.log ]; then
    cp "${HOME}"/.gamescope-stdout.log "${HOME}"/.gamescope-stdout.log.old
fi
if [ -f "${HOME}"/.gamescope-cmd.log ]; then
    cp "${HOME}"/.gamescope-cmd.log "${HOME}"/.gamescope-cmd.log.old
fi

# Start gamescope compositor, log its output and background it
echo $GAMESCOPECMD > "${HOME}"/.gamescope-cmd.log
$GAMESCOPECMD > "${HOME}"/.gamescope-stdout.log 2>&1 &
gamescope_pid="$!"

if read -r -t 3 response_x_display response_wl_display <> "$socket"; then
	export DISPLAY="$response_x_display"
	export GAMESCOPE_WAYLAND_DISPLAY="$response_wl_display"
	# We're done!
else
	log_fatal "gamescope failed"
	kill -9 "$gamescope_pid"
	wait
	exit 1
	# Systemd or Session manager will have to restart session
fi

# FIXME should be its own systemd unit
# Input method support if present
if command -v /usr/bin/ibus-daemon > /dev/null; then
   /usr/bin/ibus-daemon -d -r --panel=disable --emoji-extension=disable
   ibus_pid=$!
fi

# FIXME should be its own systemd unit
# Start Steam client
$STEAMCMD > "${HOME}"/.steam-stdout.log 2>&1

# When the client exits, kill gamescope nicely
kill $gamescope_pid
if [ -n "$ibus_pid" ]; then
	kill $ibus_pid
fi

# Start a background sleep for five seconds because we don't trust it
sleep 5 &
sleep_pid="$!"

# Catch reboot and poweroof sentinels here
if [[ -e "$STEAMOS_STEAM_REBOOT_SENTINEL" ]]; then
	rm -f "$STEAMOS_STEAM_REBOOT_SENTINEL"
	reboot
fi
if [[ -e "$STEAMOS_STEAM_SHUTDOWN_SENTINEL" ]]; then
	rm -f "$STEAMOS_STEAM_SHUTDOWN_SENTINEL"
	poweroff
fi

# Wait for gamescope or the sleep to finish for timeout purposes
ret=0
wait -n $gamescope_pid $sleep_pid || ret=$?

# If we get a SIGTERM/etc while waiting this happens.  Proceed to kill -9 everything but complain
if [[ $ret = 127 ]]; then
	log_fatal "gamescope-session: Interrupted while waiting on teardown, force-killing remaining tasks"
fi

# Kill all remaining jobs and warn if unexpected things are in there (should be just sleep_pid, unless gamescope failed
# to exit in time or we hit the interrupt case above)
for job in $(jobs -p); do
	# Warn about unexpected things
	if [[ $ret != 127 && $job = "$gamescope_pid" ]]; then
		log_fatal "gamescope-session: gamescope timed out while exiting, killing"
	elif [[ $ret != 127 && $job != "$sleep_pid" ]]; then
		log_fatal "gamescope-session: unexpected background pid $job at teardown: "
		# spew some debug about it
		log_fatal "$(ps -p "$job")"
	fi
	kill -9 "$job"
done

